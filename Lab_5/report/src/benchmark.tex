\section{Анализ системных вызовов}

\subsection{Методология анализа}

Для анализа работы программ использовалась утилита \texttt{strace}, которая позволяет отслеживать системные вызовы, выполняемые процессом. Ниже представлен детальный анализ \textbf{логов системных вызовов} для каждой лабораторной работы.

\subsection{Лабораторная работа 1: Анализ межпроцессного взаимодействия}

\subsubsection{Анализ логов с использованием каналов (Pipes)}

\begin{enumerate}
    \item \textbf{Инициализация родительского процесса}:
    \begin{verbatim}
    274130 execve("./parent", ["./parent"], 0x7ffcd3e49d68 /* 36 vars */) = 0
    \end{verbatim}
    Процесс запускается с помощью \texttt{execve()}.
    
    \item \textbf{Создание каналов связи}:
    \begin{verbatim}
    274130 pipe2([3, 4], 0) = 0
    274130 pipe2([5, 6], 0) = 0
    \end{verbatim}
    Из \textbf{вывода strace} видно создание двух каналов с дескрипторами [3,4] и [5,6].
    
    \item \textbf{Создание дочерних процессов}:
    \begin{verbatim}
    274130 clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|
                CLONE_CHILD_SETTID|SIGCHLD, 
                child_tidptr=0x79c2f68f1a10) = 274150
    \end{verbatim}
    Родительский процесс создает дочерние процессы через \texttt{clone()}.
    
    \item \textbf{Запуск дочерних программ}:
    \begin{verbatim}
    274150 execve("./child", ["./child", "child1", "file1", "3"], 
                 0x7ffd73be59b8 /* 36 vars */)
    \end{verbatim}
    Дочерний процесс запускает отдельную программу с параметрами.
\end{enumerate}

\subsubsection{Анализ протокола работы с разделяемой памятью}

\begin{enumerate}
    \item \textbf{Создание объектов разделяемой памяти}:
    \begin{verbatim}
    302509 openat(AT_FDCWD, "/dev/shm/child1_shm", 
                  O_RDWR|O_CREAT|O_NOFOLLOW|O_CLOEXEC, 0666) = 3
    302509 ftruncate(3, 4160) = 0
    302509 mmap(NULL, 4160, PROT_READ|PROT_WRITE, MAP_SHARED, 3, 0) 
            = 0x7ed6942c9000
    \end{verbatim}
    \textbf{Запись системных вызовов} показывает создание и отображение объектов разделяемой памяти.
    
    \item \textbf{Синхронизация процессов}:
    \begin{verbatim}
    302535 futex(0x7381a264a000, FUTEX_WAIT_BITSET|FUTEX_CLOCK_REALTIME, 
                 0, NULL, FUTEX_BITSET_MATCH_ANY) = 0
    \end{verbatim}
    Процессы используют \texttt{futex()} для синхронизации доступа к разделяемой памяти.
    
    \item \textbf{Пробуждение процессов}:
    \begin{verbatim}
    302509 futex(0x7ed6942ca000, FUTEX_WAKE, 1) = 1
    \end{verbatim}
    Родительский процесс пробуждает дочерние после записи данных.
\end{enumerate}

\subsection{Лабораторная работа 2: Анализ параллельной сортировки}

\subsubsection{Анализ логов многопоточного приложения}

\begin{enumerate}
    \item \textbf{Выделение памяти для массива}:
    \begin{verbatim}
    mmap(NULL, 40001536, PROT_READ|PROT_WRITE, 
         MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7e806e3da000
    \end{verbatim}
    Программа выделяет 40 МБ памяти для массива из 10 миллионов элементов.
    
    \item \textbf{Создание потоков}:
    \begin{verbatim}
    clone3({flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|
            CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|
            CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID,
            child_tid=0x7e806e3d9990, parent_tid=0x7e806e3d9990,
            exit_signal=0, stack=0x7e806dbd9000, 
            stack_size=0x7fff80, tls=0x7e806e3d96c0} 
            => {parent_tid=[124453]}, 88) = 124453
    \end{verbatim}
    Создается поток с флагом \texttt{CLONE\_THREAD}, что указывает на создание потока, а не процесса.
    
    \item \textbf{Выделение стеков для потоков}:
    \begin{verbatim}
    mmap(NULL, 8392704, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, 
         -1, 0) = 0x7e806dbd9000
    mprotect(0x7e806dbda000, 8388608, PROT_READ|PROT_WRITE) = 0
    \end{verbatim}
    Для каждого потока выделяется отдельный стек.
    
    \item \textbf{Ожидание завершения потоков}:
    \begin{verbatim}
    futex(0x7e806e3d9990, FUTEX_WAIT_BITSET|FUTEX_CLOCK_REALTIME, 
          124453, NULL, FUTEX_BITSET_MATCH_ANY) = 0
    \end{verbatim}
    Главный поток ожидает завершения рабочих потоков.
\end{enumerate}

\subsection{Лабораторная работа 4: Анализ работы с динамическими библиотеками}

\subsubsection{Анализ логов статически линкованного приложения}

\begin{enumerate}
    \item \textbf{Загрузка локальной библиотеки}:
    \begin{verbatim}
    openat(AT_FDCWD, "/home/daalginichev/OS/Lab_4/build/libcontract1.so", 
           O_RDONLY|O_CLOEXEC) = 3
    read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\0\0\0\0\0\0\0\0"..., 832) = 832
    mmap(NULL, 20632, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) 
         = 0x7be415b8e000
    \end{verbatim}
    Библиотека загружается из абсолютного пути в директории сборки.
    
    \item \textbf{Отображение секций библиотеки}:
    \begin{verbatim}
    mmap(0x7be415b90000, 4096, PROT_READ|PROT_EXEC, 
         MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x2000) = 0x7be415b90000
    mmap(0x7be415b91000, 4096, PROT_READ, 
         MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x3000) = 0x7be415b91000
    \end{verbatim}
    Различные секции библиотеки отображаются с соответствующими правами доступа.
\end{enumerate}

\subsubsection{Анализ логов динамически загружаемого приложения}

\begin{enumerate}
    \item \textbf{Динамическая загрузка библиотеки}:
    \begin{verbatim}
    openat(AT_FDCWD, "./libcontract1.so", O_RDONLY|O_CLOEXEC) = 3
    mmap(NULL, 20632, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) 
         = 0x725ea6601000
    \end{verbatim}
    Библиотека загружается из относительного пути \texttt{./libcontract1.so}.
    
    \item \textbf{Замена библиотеки во время выполнения}:
    \begin{verbatim}
    read(0, "./libcontract2.so\n", 1024) = 18
    munmap(0x725ea6601000, 20632) = 0
    openat(AT_FDCWD, "./libcontract2.so", O_RDONLY|O_CLOEXEC) = 3
    mmap(NULL, 20640, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) 
         = 0x725ea6601000
    \end{verbatim}
    Программа выгружает текущую библиотеку через \texttt{munmap()} и загружает новую.
    
    \item \textbf{Завершение программы}:
    \begin{verbatim}
    munmap(0x725ea6601000, 20640) = 0
    \end{verbatim}
    Перед завершением программа выгружает библиотеку из памяти.
\end{enumerate}
